#include <complex.h>
#include <cstdio>
#include <cmath>
#include <cuComplex.h>

#define complex _Complex
#define restrict __restrict__

extern "C"{

void gauleg(double* x1, double* x2, double x[], double w[], int* n)
{
	const double eps = 3E-14;
	const double pi  = 3.141592654;
	int m = (*n+1)/2;
	double xm = 0.5*((*x2) + (*x1));
	double xl = 0.5*((*x2) - (*x1));
	int i, j;

	for (i = 0; i < m; ++i)
	{
		double z = cos(pi*((i+1) - 0.25)/((*n) + 0.5));
		double p1, p2, pp, z1, z2;

		do
		{
			p1 = 1.0;
			p2 = 0.0;

			for (j = 0; j < (*n); ++j)
			{
				double p3 = p2;
				p2 = p1;
				p1 = ((2.0*(j) + 1.0)*z*p2 - (j)*p3)/(j+1);
			}
			pp = (*n)*(z*p1 - p2)/(z*z-1.0);
			z1 = z;
			z = z1 - p1/pp;
		} while(fabs(z - z1) > eps);
	
		x[i] = xm - xl*z;
		x[(*n)-i-1] = xm+xl*z;
		w[i] = 2.0*xl/((1.0-z*z)*pp*pp);
		w[(*n)-i-1] = w[i];
	}

}

void solfundif_(double complex zudif[3][3], 
			    double complex ztdif[3][3], 
			    double* cxp, 
			    double* cyp, 
			    double* czp, 
			    double* cxg, 
			    double* cyg, 
			    double* czg, 
			    double rn[3], 
			    double complex* zge,
			    double complex* zcs, 
			    double complex* zcp,
				double* c1,
				double* c2,
				double* c3,
				double* c4,
			    double delta[3][3], 
			    double* pi, 
			    double* fr
			 );

void solfundif (double complex zudif[3][3], 
			    double complex ztdif[3][3], 
			    double* cxp, 
			    double* cyp, 
			    double* czp, 
			    double* cxg, 
			    double* cyg, 
			    double* czg, 
			    double rn[3], 
			    double complex* zge,
			    double complex* zcs, 
			    double complex* zcp,
				double* c1,
				double* c2,
				double* c3,
				double* c4,
			    double delta[3][3], 
			    double* pi, 
			    double* fr
			 )
{
	
    double r1, r2, r3, r, drn, rd[3];
    double complex zwi, zc0, zc1, zc2, zkp, zks, zzp, zzs, zezp, zezs, 
                   zp2, zs2, zfhi, zcappa, zfhidr, zcappadr, zaa, zbb, zcc;
    
    int i, j;

    r1    = *cxg - *cxp;
    r2    = *cyg - *cyp;
    r3    = *czg - *czp;
    r     = sqrt(r1*r1 + r2*r2 + r3*r3);
    drn   = (r1*rn[0] + r2*rn[1] + r3*rn[2])/r;
    rd[0] = r1/r;
    rd[1] = r2/r;
    rd[2] = r3/r;

    zwi = 0 + (*fr) * (_Complex_I);
    
    zc0 = 1.0/(4*(*pi)*(*zge));
    zc1 = ((*zcp)/(*zcs))*((*zcp)/(*zcs));
    zc2 = ((*zcs)/(*zcp))*((*zcs)/(*zcp));
    zkp = -zwi/(*zcp);
    zks = -zwi/(*zcs);
    zzp = zkp*r;
    zzs = zks*r;
    zezp= cexp(zzp);
    zezs= cexp(zzs);
    zp2 = zzp*zzp;
    zs2 = zzs*zzs;

    zfhi    = (1 + 1./zs2 - 1./zzs)*zezs/r - zc2*(1./zp2 - 1./zzp)*zezp/r;
    zcappa  = (1 + 3./zs2 - 3./zzs)*zezs/r - zc2*(1 + 3./zp2 - 3./zzp)*zezp/r;
    zfhidr  = (-2+ zzs + 3./zzs - 3./zs2)*zezs/(r*r) - zc2*(-1 + 3./zzp - 3./zp2)*zezp/(r*r);
    zcappadr= (zzs - 4. + 9./zzs - 9./zs2)*zezs/(r*r) - zc2*(zzp - 4. + 9./zzp - 9./zp2)*zezp/(r*r);

    zaa = zfhidr-zcappa/r;
    zbb = 4.*zcappa/r - 2.*zcappadr;
    zcc = (zc1-2.)*(zaa + 0.5*zbb-3.0*zcappa/r)-2.0*zcappa/r;

    for (j = 0; j < 3; ++j)
    {   for (i = 0; i < 3; ++i)
        {
            zudif[j][i] = zc0*(zfhi*delta[j][i] - zcappa*rd[j]*rd[i]) - ((*c1)/r)*((*c2)*delta[j][i] + rd[i]*rd[j]);
//        	ztdif[j][i] = (1.0/(4.0*(*pi)))*((zaa*(drn*delta[j][i]+rd[j]*rn[i])) + rd[i]*rd[j]*drn*zbb + rd[i]*rn[j]*zcc) + ((*c3)/(r*r))*(rdn*((*c4)*delta[j][i] + 3.0*rd[i]*rd[j] + (*c4)*(rd[j]*rn[i] - rd[i]*rn[j]));	
        	ztdif[j][i] = (1.0/(4.0*(*pi)))*((zaa*(drn*delta[j][i]+rd[j]*rn[i])) +
					rd[i]*rd[j]*drn*zbb + rd[i]*rn[j]*zcc) + 
					((*c3)/(r*r))*(drn*((*c4)*delta[j][i] + 
					3.0*rd[i]*rd[j]) + 
					(*c4)*(rd[j]*rn[i] - rd[i]*rn[j]));
		}
    }
}

void sing_de_(double complex zhelem[3][3],
              double complex zgelem[3][3],
              double co[3][4],
              double* cxm,
              double* cym,
              double* czm,
              double eta[3],
              double complex* zge,
              double complex* zcs,
              double complex* zcp,
              double* c1,
              double* c2,
              double* c3,
              double* c4,
              double delta[3][3],
              double* pi,
              double* fr,
              int* npg
              );



void sing_de( double complex zhdifel[3][3],
              double complex zgdifel[3][3],
              double co[3][4],
              double* cxp,
              double* cyp,
              double* czp,
              double eta[3],
              double complex* zge,
              double complex* zcs,
              double complex* zcp,
              double* c1,
              double* c2,
              double* c3,
              double* c4,
              double delta[3][3],
              double* pi,
              double* fr,
              int* npg
              )
{
    double complex zudif[3][3];
    double complex ztdif[3][3];
    double gi[*npg], ome[*npg], p[4][2], xj[3][2], f[4];
	double g1, g2, p1, p2, p12, sp, sm, rp, rm, temp, det;
    double cxg, cyg, czg;
    double j1, j2, j3;
	double minus1 = -1;
	double plus1  = +1;
    int i, j, k, ig, jg;

    for (j = 0; j < 3; ++j)
        for (i = 0; i < 3; ++i)
        {
            zhdifel[j][i] = 0;
            zgdifel[j][i] = 0;
        }

    gauleg(&minus1, &plus1, gi , ome , npg);

    for (jg = 0; jg < *npg; ++jg)
    {
        g2 = gi[jg];
        p2 = ome[jg];
        sp = 1 + g2;
        sm = 1 - g2;
        p[0][0] = -0.25*sm;
        p[1][0] =  0.25*sm;
        p[2][0] =  0.25*sp;
        p[3][0] = -0.25*sp;

        for (ig = 0; ig < *npg; ++ig)
        {
            g1 = gi[ig];
            p1 = ome[ig];
            rp = 1 + g1;
            rm = 1 - g1;
            f[0] = 0.25*rm*sm;
            f[1] = 0.25*rp*sm;
            f[2] = 0.25*rp*sp;
            f[3] = 0.25*rm*sp;
            p[0][1] = -0.25*rm;
            p[1][1] = -0.25*rp;
            p[2][1] = 0.25*rp;
            p[3][1] = 0.25*rm;

            for (i = 0; i < 2; ++i)
            {
                for (j = 0; j < 3; ++j)
                {
                    temp = 0;
                    for (k = 0; k < 4; ++k)
                        temp = temp + p[k][i]*co[j][k];
                    xj[j][i] = temp;
                }
            }

            j1 = xj[1][0]*xj[2][1]-xj[1][1]*xj[2][0];
            j2 = xj[0][1]*xj[2][0]-xj[0][0]*xj[2][1];
            j3 = xj[0][0]*xj[1][1]-xj[0][1]*xj[1][0];

            det = sqrt(j1*j1 + j2*j2 + j3*j3);

            if (det < 1e-5)
            {
                printf("JACOBIANO NULO OU NEGATIVO!!!\n");
            }

			cxg = 0;
			cyg = 0;
			czg = 0;
			for (i = 0; i < 4; ++i)
			{
				cxg = cxg + co[0][i]*f[i];
				cyg = cyg + co[1][i]*f[i];
				czg = czg + co[2][i]*f[i];
			}

			solfundif_(zudif, ztdif, cxp, cyp, czp, &cxg, &cyg, &czg, eta, zge, zcs, zcp, c1, c2, c3, c4, delta, pi, fr);

			p12 = p1*p2*det;
			for (j = 0; j < 3; ++j)
			{
				for (i = 0; i < 3; ++i)
				{
					zhdifel[j][i] = zhdifel[j][i] + ztdif[j][i]*p12;
					zgdifel[j][i] = zgdifel[j][i] + zudif[j][i]*p12;
				}
			}
        }
    }
}

void nonsingd_(double complex zhelem[3][3],
               double complex zgelem[3][3],
              double co[3][4],
              double* cxm,
              double* cym,
              double* czm,
              double eta[3],
              double complex* zge,
              double complex* zcs,
              double complex* zcp,
              double delta[3][3],
              double* pi,
              double* fr,
              int* npg
              );



void gauleg_(double* x1, double* x2, double x[], double w[], int* n);


void solfund_(double complex zu[3][3], 
			  double complex zt[3][3], 
			  double* cxp, 
			  double* cyp, 
			  double* czp, 
			  double* cxg, 
			  double* cyg, 
			  double* czg, 
			  double rn[3], 
			  double complex* zge,
			  double complex* zcs, 
			  double complex* zcp, 
			  double delta[3][3], 
			  double* pi, 
			  double* fr
			 );

void solfund(double complex zu[3][3], 
			  double complex zt[3][3], 
			  double* cxp, 
			  double* cyp, 
			  double* czp, 
			  double* cxg, 
			  double* cyg, 
			  double* czg, 
			  double rn[3], 
			  double complex* zge,
			  double complex* zcs, 
			  double complex* zcp, 
			  double delta[3][3], 
			  double* pi, 
			  double* fr
			 )
{
    double r1, r2, r3, r, drn, rd[3];
    double complex zwi, zc0, zc1, zc2, zkp, zks, zzp, zzs, zezp, zezs, 
                   zp2, zs2, zfhi, zcappa, zfhidr, zcappadr, zaa, zbb, zcc;
    
    int i, j;

    r1    = *cxg - *cxp;
    r2    = *cyg - *cyp;
    r3    = *czg - *czp;
    r     = sqrt(r1*r1 + r2*r2 + r3*r3);
    drn   = (r1*rn[0] + r2*rn[1] + r3*rn[2])/r;
    rd[0] = r1/r;
    rd[1] = r2/r;
    rd[2] = r3/r;

    zwi = 0 + (*fr) * (_Complex_I);
    
    zc0 = 1.0/(4*(*pi)*(*zge));
    zc1 = ((*zcp)/(*zcs))*((*zcp)/(*zcs));
    zc2 = ((*zcs)/(*zcp))*((*zcs)/(*zcp));
    zkp = -zwi/(*zcp);
    zks = -zwi/(*zcs);
    zzp = zkp*r;
    zzs = zks*r;
    zezp= cexp(zzp);
    zezs= cexp(zzs);
    zp2 = zzp*zzp;
    zs2 = zzs*zzs;

    zfhi    = (1 + 1./zs2 - 1./zzs)*zezs/r - zc2*(1./zp2 - 1./zzp)*zezp/r;
    zcappa  = (1 + 3./zs2 - 3./zzs)*zezs/r - zc2*(1 + 3./zp2 - 3./zzp)*zezp/r;
    zfhidr  = (-2+ zzs + 3./zzs - 3./zs2)*zezs/(r*r) - zc2*(-1 + 3./zzp - 3./zp2)*zezp/(r*r);
    zcappadr= (zzs - 4. + 9./zzs - 9./zs2)*zezs/(r*r) - zc2*(zzp - 4. + 9./zzp - 9./zp2)*zezp/(r*r);

    zaa = zfhidr-zcappa/r;
    zbb = 4.*zcappa/r - 2.*zcappadr;
    zcc = (zc1-2.)*(zaa + 0.5*zbb-3.0*zcappa/r)-2.0*zcappa/r;

    for (j = 0; j < 3; ++j)
    {   for (i = 0; i < 3; ++i)
        {
            zu[j][i] = zc0*(zfhi*delta[j][i] - zcappa*rd[j]*rd[i]);
        	zt[j][i] = (1.0/(4.0*(*pi)))*((zaa*(drn*delta[j][i]+rd[j]*rn[i])) + rd[i]*rd[j]*drn*zbb + rd[i]*rn[j]*zcc);
		}
    }
}



void nonsingd(double complex zhelem[3][3],
              double complex zgelem[3][3],
              double co[3][4],
              double* cxp,
              double* cyp,
              double* czp,
              double eta[3],
              double complex* zge,
              double complex* zcs,
              double complex* zcp,
              double delta[3][3],
              double* pi,
              double* fr,
              int* npg
              )
{
    double complex zu[3][3];
    double complex zt[3][3];
    double gi[*npg], ome[*npg], p[4][2], xj[3][2], f[4];
	double g1, g2, p1, p2, p12, sp, sm, rp, rm, temp, det;
    double cxg, cyg, czg;
    double j1, j2, j3;
	double minus1 = -1;
	double plus1  = +1;
    int i, j, k, ig, jg;

    for (j = 0; j < 3; ++j)
        for (i = 0; i < 3; ++i)
        {
            zhelem[j][i] = 0;
            zgelem[j][i] = 0;
        }

    gauleg(&minus1, &plus1, gi , ome , npg);

    for (jg = 0; jg < *npg; ++jg)
    {
        g2 = gi[jg];
        p2 = ome[jg];
        sp = 1 + g2;
        sm = 1 - g2;
        p[0][0] = -0.25*sm;
        p[1][0] =  0.25*sm;
        p[2][0] =  0.25*sp;
        p[3][0] = -0.25*sp;

        for (ig = 0; ig < *npg; ++ig)
        {
            g1 = gi[ig];
            p1 = ome[ig];
            rp = 1 + g1;
            rm = 1 - g1;
            f[0] = 0.25*rm*sm;
            f[1] = 0.25*rp*sm;
            f[2] = 0.25*rp*sp;
            f[3] = 0.25*rm*sp;
            p[0][1] = -0.25*rm;
            p[1][1] = -0.25*rp;
            p[2][1] = 0.25*rp;
            p[3][1] = 0.25*rm;

            for (i = 0; i < 2; ++i)
            {
                for (j = 0; j < 3; ++j)
                {
                    temp = 0;
                    for (k = 0; k < 4; ++k)
                        temp = temp + p[k][i]*co[j][k];
                    xj[j][i] = temp;
                }
            }

            j1 = xj[1][0]*xj[2][1]-xj[1][1]*xj[2][0];
            j2 = xj[0][1]*xj[2][0]-xj[0][0]*xj[2][1];
            j3 = xj[0][0]*xj[1][1]-xj[0][1]*xj[1][0];

            det = sqrt(j1*j1 + j2*j2 + j3*j3);

            if (det < 1e-5)
            {
                printf("JACOBIANO NULO OU NEGATIVO!!!\n");
            }

			cxg = 0;
			cyg = 0;
			czg = 0;
			for (i = 0; i < 4; ++i)
			{
				cxg = cxg + co[0][i]*f[i];
				cyg = cyg + co[1][i]*f[i];
				czg = czg + co[2][i]*f[i];
			}

			solfund(zu, zt, cxp, cyp, czp, &cxg, &cyg, &czg, eta, zge, zcs, zcp, delta, pi, fr);

			p12 = p1*p2*det;
			for (j = 0; j < 3; ++j)
			{
				for (i = 0; i < 3; ++i)
				{
					zhelem[j][i] = zhelem[j][i] + zt[j][i]*p12;
					zgelem[j][i] = zgelem[j][i] + zu[j][i]*p12;
				}
			}
        }
    }
}

void cpp_ghmatecd_(int* ne,
                    int* nbe,
                    int* nx,
                    int* npg,
                    int* ncox,
					int* n,
					int* cone_,
					double cx[],
                    double cy[],
                    double cz[],
                    double cxm[],
                    double cym[],
                    double czm[],
                    double etas[][3],
                    double complex* zge,
                    double complex* zcs,
                    double complex* zcp,
                    double* c1,
                    double* c2,
                    double* c3,
                    double* c4,
                    double delta[3][3],
                    double* pi,
                    double* fr,
                    double* zhest_,
					double* zgest_,
					double complex* zgp_,
                    double complex* zhp_,
					int* status
                   )
{
    double co[3][4];
    int n1, n2, n3, n4;
    int i, j, ii, jj;
    double complex zgelem[3][3];
	double complex zhelem[3][3];

	/*Cast os parÃ¢metros de volta para o tipo original*/
	int (*cone)[*ne]           = (int (*)[*ne]) cone_;
	double (*zhest)[*nx]       = (double (*)[*nx]) zhest_;
	double (*zgest)[*nx]       = (double (*)[*nx]) zgest_;
	double complex (*zgp)[*nx] = (double complex (*)[*nx]) zgp_;
	double complex (*zhp)[*nx] = (double complex (*)[*nx]) zhp_;
/*	
	double co_cpy[3][4];
	int cone_cpy[4][*ne];
	double cxm_cpy[*ne], cym_cpy[*ne], czm_cpy[*ne];
	double eta_cpy[3];
	double complex zge_cpy, zcs_cpy, zcp_cpy;
	double delta_cpy[3][3];
	double pi_cpy, fr_cpy;
	int npg_cpy;
*/

	for (j = 0; j < *n; ++j)
    {

		n1 = cone[0][j];
        n2 = cone[1][j];
        n3 = cone[2][j];
        n4 = cone[3][j];

        co[0][0] = cx[n1 - 1];
        co[1][0] = cy[n1 - 1];
        co[2][0] = cz[n1 - 1];
        co[0][1] = cx[n2 - 1];
        co[1][1] = cy[n2 - 1];
        co[2][1] = cz[n2 - 1];
        co[0][2] = cx[n3 - 1];
        co[1][2] = cy[n3 - 1];
        co[2][2] = cz[n3 - 1];
        co[0][3] = cx[n4 - 1];
        co[1][3] = cy[n4 - 1];
        co[2][3] = cz[n4 - 1];

        jj = 3*j;
        for (i = 0; i < *nbe; ++i)
        {
            ii = 3*i;

            if (i == j)
            {
                sing_de_(zhelem, 
                         zgelem, 
                         co, 
                         &cxm[i], 
                         &cym[i], 
                         &czm[i], 
                         etas[j],
                         zge,
                         zcs,
                         zcp,
                         c1,
                         c2,
                         c3,
                         c4,
                         delta,
                         pi,
                         fr,
                         npg
                        );
                for (int jjj = 0; jjj < 3; ++jjj)
				{   for (int iii = 0; iii < 3; ++iii)
                    {
                        zgp[jjj+jj][iii+ii] = zgelem[jjj][iii] + zgest[jjj+jj][iii+ii];
                        zhp[jjj+jj][iii+ii] = zhelem[jjj][iii] + zhest[jjj+jj][iii+ii];
                    }
				}
            }
            else
            {
/*				
				for (int y = 0; y < 3; ++y)
				{
					for (int x = 0; x < 4; ++x)
					{
						co_cpy[y][x] = co[y][x];
					}
				}

				for (int x = 0; x < *ne; ++x)
				{
					cxm_cpy[x] = cxm[x];
					cym_cpy[x] = cym[x];
					czm_cpy[x] = czm[x];
				}

				for (int x = 0; x < 3; ++x)
				{
					eta_cpy[x] = etas[j][x];
				}
	
				zge_cpy = *zge;
				zcs_cpy = *zcs;
				zcp_cpy = *zcp;
				
				for (int y = 0; y < 3; ++y)
					for (int x = 0; x < 3; ++x)
						delta_cpy[y][x] = delta[y][x];

				pi_cpy = *pi;
				fr_cpy = *fr;
				npg_cpy = *npg;
*/
                nonsingd_(zhelem, 
                          zgelem, 
                          co, 
                          &cxm[i], 
                          &cym[i], 
                          &czm[i],
                          etas[j],
                          zge,
                          zcs,
                          zcp,
                          delta,
                          pi,
                          fr,
                          npg
                         );
			
				for (int jjj = 0; jjj < 3; ++jjj)
				{   for (int iii = 0; iii < 3; ++iii)
                    {
                        zgp[jjj+jj][iii+ii] = zgelem[jjj][iii];
                        zhp[jjj+jj][iii+ii] = zhelem[jjj][iii];
                    }
				}

				nonsingd(zhelem, 
                          zgelem, 
                          co, 
                          &cxm[i], 
                          &cym[i], 
                          &czm[i],
                          etas[j],
                          zge,
                          zcs,
                          zcp,
                          delta,
                          pi,
                          fr,
                          npg
                         );
/*
				for (int y = 0; y < 3; ++y)
				{
					for (int x = 0; x < 4; ++x)
					{
						if (co[y][x] != co_cpy[y][x])
							printf("CO ALTERADO!, %d, %d\n", i, j);
					}
				}

				for (int x = 0; x < *ne; ++x)
				{
					if (cxm_cpy[x] != cxm[x])
						printf("CXM ALTERADO!, %d, %d\n", i, j);
					if (cym_cpy[x] != cym[x])
						printf("CYM ALTERADO!, %d, %d\n", i, j);
					if (czm_cpy[x] != czm[x])
						printf("CZM ALTERADO!, %d, %d\n", i, j);
				}

				for (int x = 0; x < 3; ++x)
				{
					if (eta_cpy[x] != etas[j][x])
						printf("ETA ALTERADO!");
				}


				if (zge_cpy != *zge)
					printf("ZGE ALTERADO!\n");
				if (zcs_cpy != *zcs)
					printf("ZCS ALTERADO!\n");
				if (zcp_cpy != *zcp)
					printf("ZCP ALTERADO!\n");

				if (fr_cpy != *fr)
					printf("FR ALTERADO!\n");
				if (pi_cpy != *pi)
					printf("PI ALTERADO!\n");
				if (npg_cpy != *npg)
					printf("NPG ALTERADO!\n");
*/				
                for (int jjj = 0; jjj < 3; ++jjj)
				{   for (int iii = 0; iii < 3; ++iii)
                    {
                        if (zgp[jjj+jj][iii+ii] != zgelem[jjj][iii])
							printf("ZG i: %d, j: %d\n", i, j);
                        if (zhp[jjj+jj][iii+ii] != zhelem[jjj][iii])
							printf("ZH i: %d, j: %d\n", i, j);
                    }
				}

			}
        }
    }
}

void cuda_assert(cudaError_t error)
{
	if (error != cudaSuccess)
	{
		fputs(cudaGetErrorString(cudaGetLastError()), stderr);
		exit(1);
	}
}

__host__ __device__ __forceinline__ cuDoubleComplex cuCexp(cuDoubleComplex z)
{
    cuDoubleComplex x;
    double temp = exp(z.x);
    sincos(z.y, &x.y, &x.x);
    x.x = x.x * temp;
    x.y = x.y * temp;
    return x;
}

__global__ void ghmatecd_kernel(int ne, 
		                   int nbe, 
						   int nx, 
						   int npg, 
						   int ncox, 
						   int n,
						   cuDoubleComplex* zh,
						   cuDoubleComplex* zg,
						   cuDoubleComplex zge,
						   cuDoubleComplex zcs,
						   cuDoubleComplex zcp,
						   double* zhest_,
						   double* zgest_,
						   double* cx,
						   double* cy,
						   double* cz,
						   double* cxm,
						   double* cym,
						   double* czm,
						   double* gi,
						   double* ome,
						   double delta[3][3],
						   double rn[][3],
						   double fr,
						   int* cone
						   )
{
	int i = blockIdx.y;
	int j = blockIdx.x;
	int index = 3*blockIdx.y + 3*blockIdx.x*nx + threadIdx.x*nx + threadIdx.y;
	
	__shared__ double p[4][2], xj[3][2], f[4];
	__shared__ double g0, g1, g2, p1, p2, p12, sp, sm, rp, rm, temp, det;
    double cxg, cyg, czg, cxp, cyp, czp;
    __shared__ double j1, j2, j3;
	__shared__ double co[3][4];
    __shared__ double r1, r2, r3, r, drn, rd[3];
    __shared__ cuDoubleComplex zwi, zc0, zc1, zc2, zkp, zks, zzp, zzs, zezp, zezs, zr, zr2, 
                    zp2, zs2, zfhi, zcappa, zfhidr, zcappadr, zaa, zbb, zcc;

    const cuDoubleComplex one   = make_cuDoubleComplex(1.0, 0);
    const cuDoubleComplex two   = make_cuDoubleComplex(2.0, 0);
    const cuDoubleComplex three = make_cuDoubleComplex(3.0, 0); 
    const cuDoubleComplex four  = make_cuDoubleComplex(4.0, 0); 
    const cuDoubleComplex nine  = make_cuDoubleComplex(9.0, 0); 
	
	const double pi  = 3.141592654;
	
	double temp1, temp2, temp3, temp4;

	int n1 = cone[ne*0 + j];
	int n2 = cone[ne*1 + j];
	int n3 = cone[ne*2 + j];
	int n4 = cone[ne*3 + j];

	int ig, jg, ii, jj;

	co[0][0] = cx[n1 - 1];
	co[1][0] = cy[n1 - 1];
	co[2][0] = cz[n1 - 1];
	co[0][1] = cx[n2 - 1];
	co[1][1] = cy[n2 - 1];
	co[2][1] = cz[n2 - 1];
	co[0][2] = cx[n3 - 1];
	co[1][2] = cy[n3 - 1];
	co[2][2] = cz[n3 - 1];
	co[0][3] = cx[n4 - 1];
	co[1][3] = cy[n4 - 1];
	co[2][3] = cz[n4 - 1];

	cxp = cxm[i];
	cyp = cym[i];
	czp = czm[i];

	zh[index] = make_cuDoubleComplex(0, 0);
	zg[index] = make_cuDoubleComplex(0, 0);
    
	for (jg = 0; jg < npg; ++jg)
	{
	
		g2 = gi[jg];
		p2 = ome[jg];
		sp = 1 + g2;
		sm = 1 - g2;
		p[0][0] = -0.25*sm;
		p[1][0] =  0.25*sm;
		p[2][0] =  0.25*sp;
		p[3][0] = -0.25*sp;

		for (ig = 0; ig < npg; ++ig)
		{
			g1 = gi[ig];
			p1 = ome[ig];
			rp = 1 + g1;
			rm = 1 - g1;
			f[0] = 0.25*rm*sm;
			f[1] = 0.25*rp*sm;
			f[2] = 0.25*rp*sp;
			f[3] = 0.25*rm*sp;
			p[0][1] = -0.25*rm;
			p[1][1] = -0.25*rp;
			p[2][1] = 0.25*rp;
			p[3][1] = 0.25*rm;

            for (ii = 0; ii < 2; ++ii)
            {
                for (jj = 0; jj < 3; ++jj)
                {
                    xj[jj][ii] = p[0][ii]*co[jj][0] + p[1][ii]*co[jj][1]+ p[2][ii]*co[jj][2] + p[3][ii]*co[jj][3];
                }
            }

            j1 = xj[1][0]*xj[2][1]-xj[1][1]*xj[2][0];
            j2 = xj[0][1]*xj[2][0]-xj[0][0]*xj[2][1];
            j3 = xj[0][0]*xj[1][1]-xj[0][1]*xj[1][0];

            det = sqrt(j1*j1 + j2*j2 + j3*j3);


            if (det < 1e-5)
            {
                //algo deveria acontecer
            }


			cxg = 0;
			cyg = 0;
			czg = 0;
			for (ii = 0; ii < 4; ++ii)
			{
				cxg = cxg + co[0][ii]*f[ii];
				cyg = cyg + co[1][ii]*f[ii];
				czg = czg + co[2][ii]*f[ii];
			}


			r1    = cxg - cxp;
			r2    = cyg - cyp;
			r3    = czg - czp;
			r     = sqrt(r1*r1 + r2*r2 + r3*r3);
			drn   = (r1*rn[j][0] + r2*rn[j][1] + r3*rn[j][2])/r;
			rd[0] = r1/r;
			rd[1] = r2/r;
			rd[2] = r3/r;

			zr = make_cuDoubleComplex(r, 0);
			zr2 = cuCmul(zr, zr);

			zwi = make_cuDoubleComplex(0, fr);

			zc0 = cuCdiv(one,
						 cuCmul(make_cuDoubleComplex(4*pi, 0), zge));
			
			zc1 = cuCdiv(zcp, zcs);
			zc1 = cuCmul(zc1, zc1);

			zc2 = cuCdiv(zcs, zcp);
			zc2 = cuCmul(zc2, zc2);

			zkp = cuCdiv(zwi, zcp);
			zkp.x = -zkp.x; zkp.y = -zkp.y;
			
			zks = cuCdiv(zwi, zcs);
			zks.x = -zks.x; zks.y = -zks.y;

			zzp = cuCmul(zkp, make_cuDoubleComplex(r, 0));
			zzs = cuCmul(zks, make_cuDoubleComplex(r, 0));

			zezp = cuCexp(zzp);
			zezs = cuCexp(zzs);

			zp2 = cuCmul(zzp, zzp);
			zs2 = cuCmul(zzs, zzs);

			zfhi = cuCmul(cuCsub(cuCadd(one, cuCdiv(one, zs2)), cuCdiv(one, zzs)), cuCdiv(zezs, zr));
			zfhi = cuCsub(zfhi, cuCmul(zc2, cuCmul(cuCsub(cuCdiv(one, zp2), cuCdiv(one, zzp)),cuCdiv(zezp, zr))));

			zcappa = cuCmul(cuCsub(cuCadd(one, cuCdiv(three, zs2)), cuCdiv(three, zzs)), cuCdiv(zezs, zr));
			zcappa = cuCsub(zfhi, cuCmul(zc2, cuCmul(cuCadd(one, cuCsub(cuCdiv(one, zp2), cuCdiv(one, zzp))),cuCdiv(zezp, zr))));

			zfhidr = cuCmul(cuCsub(cuCsub(cuCadd(zzs, cuCdiv(three, zzs)), two),cuCdiv(three, zs2)), cuCdiv(zezs, zr2));
			//zfhidr = cuCsub(zfhidr, cuCmul(zc2, cuCmul(cuCsub(cuCsub(cuCdiv(three, zzp), cuCdiv(three, zp2)), one),cuCmul(cuCdiv(zezp, zr2)))));

//			zcappadr = cuCmul(cuCsub(cuCsub(cuCadd(zzs, cuCdiv(nine, zzs), cuCdiv(nine, zs2))), four), cuCdiv(zezs, zr2));
//			zcappadr = cuCsub(zcappadr, cuCmul(cuCmul(zc2, cuCsub(cuCsub(cuCadd(zzp, cuCdiv(nine, zzp)), cuCdiv(nine, zp2))), four), cuCdiv(zezp, r2)));

			zaa = cuCsub(zfhidr, cuCdiv(zcappa, zr));
			zbb = cuCsub(cuCdiv(cuCmul(four, zcappa), zr), cuCmul(two, zcappadr));
			zcc = cuCsub(zc1, two);
			zcc = cuCmul(zcc, cuCsub(cuCadd(zaa, cuCdiv(zbb, two)), cuCdiv(cuCmul(three, zcappa), zr)));
			zcc = cuCsub(zcc, cuCdiv(cuCmul(two, zcappa), zr));

			temp1 = 1./(4.*pi);
//			temp2 = drn*delta[threadIdx.x][threadIdx.y] + rd[threadIdx.x]*rn[threadIdx.y];
			temp3 = rd[threadIdx.y]*rd[threadIdx.x]*drn;
//			temp4 = rd[threadIdx.y]*rn[threadIdx.x];
			
			zh[index] = cuCmul(make_cuDoubleComplex(temp1, 0), cuCadd(cuCadd(cuCmul(zaa, make_cuDoubleComplex(temp2, 0)), cuCmul(zbb, make_cuDoubleComplex(temp3, 0))), cuCmul(make_cuDoubleComplex(temp4, 0), zcc)));
			zg[index] = cuCmul(
							zc0, 
							cuCsub(
								cuCmul(
									zfhi, 
									make_cuDoubleComplex(delta[threadIdx.x][threadIdx.y], 0)
								),
								cuCmul(
									zcappa,
									cuCmul(
											make_cuDoubleComplex(rd[threadIdx.x], 0),
											make_cuDoubleComplex(rd[threadIdx.y], 0)
									)
								)
							)
						);
			}
	}
}

void cuda_ghmatecd_(int* ne,
                    int* nbe,
                    int* nx,
                    int* npg,
                    int* ncox,
					int* n,
					int* cone_,
					double cx[],
                    double cy[],
                    double cz[],
                    double cxm[],
                    double cym[],
                    double czm[],
                    double etas[][3],
                    cuDoubleComplex* zge,
                    cuDoubleComplex* zcs,
                    cuDoubleComplex* zcp,
                    double* c1,
                    double* c2,
                    double* c3,
                    double* c4,
                    double delta[3][3],
                    double* pi,
                    double* fr,
                    double* zhest_,
					double* zgest_,
					double complex* zgp_,
                    double complex* zhp_,
					double gi[],
					double ome[],
					int* status
                   )
{
	dim3 threadsPerBlock(3,3);
	dim3 numBlocks(*n, *nbe);
	cudaError_t error;
	double* device_zhest;
	double* device_zgest;
	cuDoubleComplex* device_zh;
	cuDoubleComplex* device_zg;
	double* device_cx;
	double* device_cy;
	double* device_cz;
	double* device_cxm;
	double* device_cym;
	double* device_czm;
	double* device_etas;
	double* device_delta;
	int* device_cone;
	double* device_gi;
	double* device_ome;

	int i, j;


	double complex (*zgp)[*nx] = (double complex (*)[*nx]) zgp_;
	double complex (*zhp)[*nx] = (double complex (*)[*nx]) zhp_;
	
	
	error = cudaMalloc(&device_gi, (*npg)*sizeof(double));
	cuda_assert(error);

	error = cudaMalloc(&device_ome, (*npg)*sizeof(double));
	cuda_assert(error);
	
	error = cudaMalloc(&device_zh, (*nx)*(*nx)*sizeof(cuDoubleComplex));
	cuda_assert(error);

	error = cudaMalloc(&device_zg, (*nx)*(*nx)*sizeof(cuDoubleComplex));
	cuda_assert(error);
	
	error = cudaMalloc(&device_zhest, (*nx)*(*nx)*sizeof(cuDoubleComplex));
	cuda_assert(error);

	error = cudaMalloc(&device_zgest, (*nx)*(*nx)*sizeof(cuDoubleComplex));
	cuda_assert(error);

	error = cudaMalloc(&device_etas, (*nx)*3*sizeof(double));
	cuda_assert(error);

	error = cudaMalloc(&device_cx, (*ncox)*sizeof(double));
	cuda_assert(error);

	error = cudaMalloc(&device_cy, (*ncox)*sizeof(double));
	cuda_assert(error);

	error = cudaMalloc(&device_cz, (*ncox)*sizeof(double));
	cuda_assert(error);

	error = cudaMalloc(&device_cxm, (*ne)*sizeof(double));	
	cuda_assert(error);

	error = cudaMalloc(&device_cym, (*ne)*sizeof(double));	
	cuda_assert(error);
	
	error = cudaMalloc(&device_czm, (*ne)*sizeof(double));	
	cuda_assert(error);

	error = cudaMalloc(&device_delta, 3*3*sizeof(double));
	cuda_assert(error);

	error = cudaMalloc(&device_cone, 4*(*ne)*sizeof(int));
	cuda_assert(error);

	error = cudaMemcpy(device_gi, gi, (*npg)*sizeof(double), cudaMemcpyHostToDevice);
	cuda_assert(error);

	error = cudaMemcpy(device_ome, ome, (*npg)*sizeof(double), cudaMemcpyHostToDevice);
	cuda_assert(error);

	error = cudaMemcpy(device_etas, etas, (*n)*3, cudaMemcpyHostToDevice);
	cuda_assert(error);
	
	error = cudaMemcpy(device_cx, cx, (*ncox)*sizeof(double), cudaMemcpyHostToDevice);
	cuda_assert(error);
	
	error = cudaMemcpy(device_cy, cy, (*ncox)*sizeof(double), cudaMemcpyHostToDevice);
	cuda_assert(error);
	
	error = cudaMemcpy(device_cz, cz, (*ncox)*sizeof(double), cudaMemcpyHostToDevice);
	cuda_assert(error);
	
	error = cudaMemcpy(device_cxm, cxm, (*ne)*sizeof(double), cudaMemcpyHostToDevice);
	cuda_assert(error);
	
	error = cudaMemcpy(device_cym, cym, (*ne)*sizeof(double), cudaMemcpyHostToDevice);
	cuda_assert(error);
	
	error = cudaMemcpy(device_czm, czm, (*ne)*sizeof(double), cudaMemcpyHostToDevice);
	cuda_assert(error);
	
	error = cudaMemcpy(device_delta, delta, 3*3*sizeof(double), cudaMemcpyHostToDevice);
	cuda_assert(error);

	error = cudaMemcpy(device_cone, cone_, (*ne)*4*sizeof(int), cudaMemcpyHostToDevice);
	cuda_assert(error);

	error = cudaMemcpy(device_zhest, zhest_, (*nx)*(*nx)*sizeof(double), cudaMemcpyHostToDevice);
	cuda_assert(error);

	error = cudaMemcpy(device_zgest, zgest_, (*nx)*(*nx)*sizeof(double), cudaMemcpyHostToDevice);
	cuda_assert(error);

/*	
	for (i = 0; i < (*nbe)*3; ++i)
	{
		error = cudaMemcpy(device_zhest + (*n)*i, zhest_ + (*nx)*i, 3*(*n)*sizeof(cuDoubleComplex), cudaMemcpyHostToDevice);
		cuda_assert(error);
		error = cudaMemcpy(device_zgest + (*n)*i, zgest_ + (*nx)*i, 3*(*n)*sizeof(cuDoubleComplex), cudaMemcpyHostToDevice);
		cuda_assert(error);
	}
*/

	ghmatecd_kernel<<<numBlocks, threadsPerBlock>>>(*ne,
			                                        *nbe,
													*nx,
													*npg,
													*ncox,
													*n,
													device_zh,
													device_zg,
													(cuDoubleComplex) *zge,
													(cuDoubleComplex) *zcs,
													(cuDoubleComplex) *zcp,
													device_zhest,
													device_zgest,
													device_cx,
													device_cy,
													device_cz,
													device_cxm,
													device_cym,
													device_czm,
													device_gi,
													device_ome,
													(double (*)[3]) device_delta,
													(double (*)[3]) device_etas,
													*fr,
													device_cone
												   );

	/*
	for (i = 0; i < (*nbe)*3; ++i)
	{
		error = cudaMemcpy(zhp_ + (*nx)*i, device_zh + (*n)*i, 3*(*n)*sizeof(cuDoubleComplex), cudaMemcpyDeviceToHost);
		cuda_assert(error);
	}
	*/

	error = cudaMemcpy(zhp_, device_zh, (*nx)*(*nx)*sizeof(cuDoubleComplex), cudaMemcpyDeviceToHost);
	cuda_assert(error);


/*
	for (j = 0; j < *n*3; ++j)
	{
		for (i = 0; i < *nbe*3; ++i)
		{
			printf("%d %d  =   %f\n", i, j, zhp[j][i]);
		}
	}
*/

	for (j = 0; j < *n; ++j)
	{
		for (i = 0; i < *nbe; ++i)
		{
			printf("%d %d  =   %f\n", i, j, zhp[j][i]);
		}
	}

	/*
	cpp_ghmatecd_ (ne,
                    nbe,
                    nx,
                    npg,
                    ncox,
					n,
					cone_,
					cx,
                    cy,
                    cz,
                    cxm,
                    cym,
                    czm,
                    etas,
                    zge,
                    zcs,
                    zcp,
                    c1,
                    c2,
                    c3,
                    c4,
                    delta,
                    pi,
                    fr,
                    zhest_,
					zgest_,
					zgp_,
                    zhp_,
					status
                   );
	*/
}
}
